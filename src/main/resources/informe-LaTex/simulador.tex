\part{Simulador \qsim}


El simulador desarrollado es una herramienta de utilización sencilla ya que se asume que los alumnos de esta materia están en la etapa inicial de la carrera y se pretende transmitir los conceptos sin distraerlos con detalles de uso y configuración.

\section{Funcionalidad del simulador}

La funcionalidad del simulador puede caracterizarse mediante las siguientes partes importantes:

\begin{itemize}
\item Chequeo de sintaxis de los programas escritos en el lenguaje Q
\item Ensamblado del código fuente de un programa en su correspondiente código máquina
\item Cargado en memoria del código máquina
\item Ejecución paso a paso de un programa cargado en memoria
\end{itemize}

\subsection{Chequeo de sintaxis}\label{parser}

El simulador provee al alumno de un editor de texto en el cual escribirá el programa en un lenguaje Qi, que desea cargar en memoria y ejecutar.
Una vez que el usuario haya terminado la escritura, al momento de cargar el programa, el simulador utilizará un \textit{parser}\footnote{\verde{Definir parser en esta nota al pie}{}} para detectar errores de sintaxis, tales como la falta de una coma o un corchete, o la presencia de símbolos que no pertenecen al lenguaje (como por ejemplo signos de pregunta y símbolos matemáticos); o bien errores semánticos como la combinación incorrecta de elementos del lenguaje, por ejemplo: modos de direccionamiento mal ubicados.
El parser solo revisará lo escrito por el alumno y de acuerdo a las gramática del lenguaje, mostrará alguno de los siguientes estados:

\begin{description}
\item[OK] Este mensaje se obtiene cuando no hubo ningún error de sintaxis. Si se da este resultado, es posible continuar con el ensamblado y cargado en memoria.
\item[SyntaxError] Este mensaje de error se obtiene cuando en alguna línea del programa se detectó algún error de sintaxis o de semántica, como se describió arriba. Cuando ocurre este error se lo acompaña con una descripción lo mas detallada posible para que el alumno detecte donde ocurrió y pueda corregirlo. Un programa con errores no puede ser ensamblado y cargado en memoria.
\end{description}

\subsection{Ensamblado}

Una vez que el programa es sintácticamente válido es posible traducir el código fuente del programa en código máquina (representado en cadenas binarias). Para esto se respeta un formato de instrucción que indica cómo se codifica cada operación y los operandos. \\
Mas detalle al respecto de este proceso en el apéndice \ref{apendiceQ}.

\subsection{Cargado en memoria}

Una vez ensamblado, la representación binaria (o código máquina) del programa será cargado en memoria a partir de una ubicación (celda de memoria) que el alumno puede elegir. Esto permite visualizar el contenido de la memoria (con el programa cargado) y el estado de los registros de la CPU. \verde{La decodificación con desensamblado permite al alumno experimentar otros escenarios y efectos laterales, entre los cuales podemos enumerar:

\begin{itemize}
\item Si la ejecución paso a paso excede los límites del programa, pueden tomarse instrucciones de otra rutina y procesarse como una nueva instruccion.
\item Si en cambio, se intenta ejecutar el contenido de una celda con datos (y no una instrucción) podrá ocurrir que se encuentre una instrucción invalida (por ejemplo, una combinación incorrecta de modos de direccionamiento y códigos de operación) y el alumno verá el mensaje de error pertinente.
\end{itemize}}{Esto me parece que no corresponde aca, sino mas adelante}

Durante la carga del programa en memoria puede ocurrir que el programa no cuenta con el espacio suficiente a partir de la ubicación elegida ya que ocupa más celdas que las que se encuentran disponibles, ya que como se especifica en el apéndice \ref{apendiceQ}, la memoria disponible tiene un tamaño limitado y por este motivo la alocación en memoria del código máquina puede exceder el espacio disponible a partir de la celda inicial anteriormente elegida. Si por el contrario, no se produce este error, el alumno podrá ver el programa cargado en memoria exitosamente.

\subsection{Ejecución paso a paso}

Se provee la funcionalidad de la ejecución paso a paso ya que se desea que el alumno pueda experimentar y así comprender los pasos del ciclo de ejecución. Además puede ejercitarse situaciones que se denominan ''errores conceptuales de programación'' Esto es a lo que llamamos Errores conceptuales, entre los cuales es posible mencionar:

\begin{itemize}
\item Tomar un dato de un sector de memoria equivocado.
\item Que el programa sobrescriba su mismo código máquina.
\item Permitir que la ejecución continue una vez procesadas las instrucciones del programa cargado en memoria.
\end{itemize}

El paso a paso que provee el simulador consiste en las siguientes etapas pertenecientes al \ciclo:

\begin{enumerate}
\item \textbf{Búsqueda de instrucción:} El alumno podrá visualizar el valor que contiene PC (Program counter) donde se encuentra la dirección de la celda en memoria que contiene la próxima instrucción a ejecutar (por ejemplo, en caso de ser la primer instrucción del programa recién cargado, el pc tendrá la dirección de memoria elegida por el alumno para iniciar el cargado del programa en memoria). El simulador, toma de la memoria el código maquina correspondiente a la instrucción que comienza en esa dirección tomada de PC (una instrucción puede ocupar más de una celda de memoria) y los guarda en el \IR\ (\textit{Instruction Register}). Será observable también para el alumno el incremento del registro PC, tantas como celdas ocupe la instrucción actual, lo que conceptualmente es, preparar el contexto de ejecución para tomar la siguiente instrucción.

\item  \textbf{Decodificación:}
En la decodificación el Interprete se encarga de desensamblar el código máquina (abreviado en hexadecimal) que ya fue ubicado en el \IR para mostrar el código fuente de la instrucción actual con sus respectivos operandos. Si el programa escrito por el alumno es sintacticamente y conceptualmente correcto, este paso le permite comprobar que la instrucción actual es la que él mismo escribió y no otra, visualizandola en pantalla. En esta etapa se provee también la oportunidad de que el alumno aprecie otros conceptos, tales como los errores conceptuales mencionados antes.

\item  \textbf{Ejecución}
El execute ejecuta los efectos de la instrucción y muestra en pantalla los cambios en el estado de ejecución: memoria, puertos, registros y flags. Dentro de esta misma etapa se lleva a cabo el almacenamiento de resultados que, cuando sea necesario, guardará el valor resultante de la operación descripta por la instrucción en el operando destino. Esto cambiará el valor de una celda de memoria o de un registro y será visto en pantalla por el alumno.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{Implementación}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Tecnología utilizada}
En la presente sección se indica la tecnología elegida para la implementación del simulador, justificando dichas elecciones en cada caso.

\begin{itemize}


\item  \textbf{Lenguaje Scala.}
Elegimos el lenguaje Scala para realizar el simulador ya que durante las cursadas de las asignaturas de TPI no tuvimos la oportunidad de profundizar el dominio de este lenguaje ni aprovechar las ventajas que este ofrecía al combinar el manejo de objetos y las características de un lenguaje funcional. Es por ello que descartamos la elección de un lenguaje con el que estábamos mas familiarizadas, como por ejemplo Java.

\item  \textbf{Framework Arena.}
Utilizamos el framework Arena para realizar la interfaz de usuario del simulador porque es una herramienta de código abierto que tuvimos la oportunidad de conocer en la materia \ui. Al poder ser combinado con \textbf{Scala} nos pareció una buena oportunidad de explotar lo que nos ofrecía para simplificar la definición de la interfaz de usuario, permitiéndonos así enforcarnos en la implementación del modelo. 

\item  \textbf{Eclipse.}
Se eligió utilizar el entorno de programación Eclipse ya que es una herramienta multiplataforma, lo que nos permitió trabajar en diferentes sistemas operativos y con la cual estábamos familizadas.  Por otro lado, la comunidad provee pluggins para manejar proyectos para Scala.

\item  \textbf{Git}
Elegimos git como repositorio externo para trabajar colaborativamente durante el desarrollo, dado que es una herramienta que muy extendida en los desarrollos de software libre.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Diseño Orientado a Objetos}

\subsubsection{ALU}
Como se observa en la figura \ref{ALU} la ALU tiene toda la responsabilidad en la ejecución de operaciones matemáticas y lógicas, además del cómputo de los flags luego de cada operación. 

\graf{ALU}{Diagrama de clase de la \ALU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Bus de entrada y salida, memoria y puertos}
Como se observa en la figura \ref{BusEntradaSalida_Memoria_CeldasPuertos} el Bus de entrada y salida tiene la responsabilidad de derivar según donde corresponda (Memoria o Puertos) la escritura o lectura de un dato. Para ello conoce a una instancia de la clase Memoria y a otra de la clase CeldasPuertos. 
Ambas clases conocen una colección de instancias de la clase Celda, y cada Celda a su vez conoce un dato: una instancia de la clase W16 que representa al dato almacenado en una celda de memoria o en un puerto.  

\graf{BusEntradaSalida_Memoria_CeldasPuertos}{Diagrama de las clases del la BusEntradaSalida, Memoria, CeldasPuertos y Celda}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{CPU}
Como se observa en la figura \ref{CPU}, la CPU conoce a la ALU, contiene los registros IR y PC, los flags (V,Z,C,N) y los ocho registros de uso general (R0...R7). La responsabilidad de la CPU es actualizar los flags, los registros, actualizar el PC y el IR, y ser la conexión con la ALU.

\graf{CPU}{Diagrama de clase de la CPU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Intérprete}
Como se observa en la figura \ref{Interprete} el Interprete es un \textit{singleton} que tiene la entera responsabilidad de construir un objeto que representa una instrucción determinada a partir de la decodificación de las celdas de memoria que ocupa su código máquina. Se ocupa de la decodificación de la instrucción.

\graf{Interprete}{Diagrama de clase del Interprete}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Modos de direccionamiento y W16}

\ojo{}{Esta jerarquía de clases permite controlar el acceso a los operandos, mediante un objeto ModoDireccionamiento que controla el acceso a un objeto W16, que es quien contiene el valor propiamente dicho}. 
Como se observa en la figura \ref{ModoDireccionamiento} los modos de direccionamiento extienden del trait ModoDireccionamiento, donde se encuentran declarados mensajes necesarios para manejar todas las subclases de manera polimórfica. Entre estos mensajes podemos enumerar:
\begin{itemize}
\item  \textbf{representacionString:}
Devuelve la representación en string como código fuente, por ejemplo la representación de un \ojo{}{objeto?} \textbf{ADD(R0,R7)}, sería: \code{ADD R0, R7}\ojo{}{(aclarar) este mensaje se utiliza en la etapa de desensamblado}
\item  \textbf{codigo:}
Retorna el string que representa al código del modo de direccionamiento, por el ejemplo, el código de modo de direccionamiento del R7 es \code{100111}. \ojo{}{(aclarar) este mensaje se utiliza en la etapa de ensamblado}
\item  \textbf{getValorString:}
Retorna el dato almacenado en el operando. En el caso de un Inmediato que sea \code{FF56}, devolverá el string "FF56", y en el caso de cualquier registro, retornara el valor que represente su W16.
\end{itemize}


La clase W16 que también esta en la figura \ref{ModoDireccionamiento}, representa el dato que es guardado en memoria. Tiene la \ojo{responsabilidad}{capacidad} de incrementarse, decrementarse, sumar una entero, devolver su representación binaria y su valor en decimal.\\

Los modos de direccionamiento diferentes a Inmediato y Registro, conocen otro modo de direccionamiento que encapsula al objeto \textbf{W16} según corresponda, es decir:
\begin{itemize}
\item \textbf{RegistroIndirecto} conoce una instancia de Registro.
\item \textbf{Directo} conoce conoce una instancia de Inmediato.
\item \textbf{Indirecto} conoce conoce una instancia de Directo.
\end{itemize}
\ojo{Esto se implemento de esta manera para que el leer datos de memoria, puertos o registros, o guardarlos en los mismos sea más sencillo ya que se delega en el modo de direccionamiento que conoce.}{(esto lo sacaría)}

La clase \textbf{Etiqueta} representa las etiquetas creadas por el alumno cuando realiza el programa. Cuando el mismo es cargado en memoria, en función de cual sea la celda de inicio y cuanto ocupen las instrucciones, se calcula la dirección de memoria a la que hace referencia y luego se la descarta reemplazándola por un modo de direccionamiento Inmediato.

\graf[15cm]{ModoDireccionamiento}{Diagrama de clase de la jerarquía de los modos de direccionamiento}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Instrucciones}
Como se observa en la figura \ref{Instruccion} las Instrucciones están \ojo{modeladas en jerarquias que se dividen en}{jerarquizadas en}:

\begin{itemize}
\item Instrucciones de un operando.
\item Instrucciones de dos operandos.
\item Instrucciones de sin operandos.
\item Saltos condicionales.
\end{itemize}

Se realizó dicha jerarquía para permitir la fácil \ojo{agregación}{incorporación} de nuevas instrucciones \ojo{siendo}{como} subclases de la clase que corresponda ya que \ojo{comparten}{de ese modo se reutiliza} comportamiento tal como la manera de mostrarse (en términos de código fuente) y de codificarse (en términos de \codmaq).

\graf{Instruccion}{Diagrama de clase de la Instrucción}

\begin{description}
\item[Instrucciones sin operandos] Como se observa en la figura \ref{Instruccion_SinOperandos} la única instrucción sin operandos implementada en la arquitectura Q es la instrucción \code{RET}. A pesar de esto, se eligió hacer una jerarquía para que luego se facilite \ojo{la inserción al modelo de nuevas instrucciones sin operandos}{la escalabilidad del modelo, permitiendo la inserción de nuevas instrucciones sin operandos}.

\graf[4cm]{Instruccion_SinOperandos}{Detalle de clase Instruccion\_SinOperandos}

\item[Instrucciones de un operando] 
Como se observa en la figura \ref{Instruccion_UnOperando} y \ojo{concordando en lo}{siguiendo con el criterio} mencionado antes sobre la jerarquía de instrucciones, puede haber dos tipos de instrucciones de un operando:

\begin{itemize}
\item Un operando origen.
\item Un operando destino.
\end{itemize}

Ambas clases de instrucciones tienen un solo operando. La diferencia entre ellas es la lógica de ejecución y la manera en la que se ensamblan y desensamblan ya que sus formato de instrucción difiere\ojo{ en donde esta colocado el relleno}{(ver apéndice \ref{apendiceQ})}.

\graf[15cm]{Instruccion_UnOperando}{Diagrama de clase de la Instruccion\_UnOperando}


\item[Instrucciones de dos operandos]

Como se observa en la figura \ref{Instruccion_DosOperandos} la jerarquía de clases de instrucciones de dos operandos es la más amplia por tener mayor cantidad de instrucciones. Todas comparten \ojo{la manera de }{el comportamiento para la} decodificación e interpretación, además de la lógica de impresión.

\graf[15cm]{Instruccion_DosOperandos}{Diagrama de clase de la Instruccion\_DosOperandos}

\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Programa}

Como se observa en la figura \ref{Programa} la clase Programa conoce un grupo de Instrucciones (las instrucciones que lo componen). Las instancias son creadas por el \textit{parser} (ver sección \ref{parser}), luego se calculan las etiquetas (si es que las tiene) y finalmente cuando es cargado en memoria la instancia de programa es desechada ya que no vuelve a usarse en ningún momento de la ejecución.

\graf{Programa}{Diagrama de clase de la Programa}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Simulador}

Esta e la clase principal del modelo y la encargada de coordinar la ejecución del programa paso a paso. Como se observa en la figura \ref{simulador} la clase \textbf{Simulador} conoce a una instancia de la clase \textbf{CPU}, a una instancia de la clase \textbf{BusEntradaSalida} y a una intancia de la clase \textbf{Instruccion}, que representa a la instrucción que se esta ejecutando en ese momento.\\

La clase Simulador tiene la responsabilidad de obtener el \codmaq\ de la siguiente instrucción, colaborando con el Interprete (ver \ref{interprete}), calcular las etiquetas de un programa, cargar el programa en memoria y los datos en registros,  ejecutar las instrucciones o delegar su ejecución al objeto \textbf{ALU} que conoce a través de la \textbf{CPU} según corresponda, y guardar datos en memoria o registros (almacenamiento de resultados).

\graf[15cm]{simulador}{Diagrama de clase de la Simulador}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Como se observa en la figura \ref{}

%\graf{}{Diagrama de clase de la \}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%[width=0.7\textwidth]



